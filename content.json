[{"title":"ES5规范回顾系列(二)——内置对象","date":"2017-07-02T06:36:03.000Z","path":"2017/07/02/es5-review-2/","text":"下文摘自ES5/标准 ECMAScript 内置对象 全局对象唯一的全局对象在控制进入任何执行环境前被创建。 除非另外指明，全局对象的标准内置属性拥有特性 {[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}。 全局对象没有 [[Construct]] 内部属性 ; 全局对象不可能当做构造器用 new 运算符调用。 全局对象没有 [[Call]] 内部属性，全局对象不可能当做函数来调用。 全局对象的 [[Prototype]] 和 [[Class]] 内部属性值是依赖于实现的。 除了本规范定义的属性之外，全局对象还可以拥有额外的宿主定义的属性。全局对象可包含一个值是全局对象自身的属性；例如，在 HTML 文档对象模型中全局对象的 window 属性是全局对象自身。 全局对象的值属性NaNNaN 的值是 NaN。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。 InfinityInfinity 的值是 +∞。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。 undefinedundefined 的值是 undefined。这个属性拥有特性 &lt;{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。 全局对象的函数属性eval (x)parseInt (string, radix)parseFloat (string)isNaN (number)isFinite (number)处理 URI 的函数属性decodeURI (encodedURI)decodeURI 函数计算出一个新版 URI，将 URI 中可能是 encodeURI 函数引入的每个转义序列和 UTF-8 编码组替换为代表它们的字符。不是 encodeURI 导入的转义序列不会被替换。 decodeURIComponent (encodedURIComponent)decodeURIComponent 函数计算出一个新版 URI，将 URI 中可能是 encodeURIComponent 函数引入的每个转义序列和 UTF-8 编码组替换为代表它们的字符。 encodeURI (uri)encodeURI 函数计算出一个新版 URI，将 URI 中某些字符的每个实例替换为代表这些字符 UTF-8 编码的一个，两个或三个转义序列。 encodeURIComponent (uriComponent)encodeURIComponent 函数计算出一个新版 URI，将 URI 中某些字符的每个实例替换为代表这些字符 UTF-8 编码的一个，两个或三个转义序列。 *encodeURI 和 decodeURI 函数操作的是完整的 URI；这俩函数假定 URI 中的任何保留字符都有特殊意义，所有不会编码它们。encodeURIComponent 和 decodeURIComponent 函数操作的是组成 URI 的个别组件；这俩函数假定任何保留字符都代表普通文本，所以必须编码它们，所以它们出现在组成一个完整 URI 的组件里面时不会解释成保留字符了。 全局对象的构造器属性Object ( . . . )作为函数调用 Object 构造器当把 Object 当做一个函数来调用，而不是一个构造器，它会执行一个类型转换。 Object ( [ value ] )当以一个参数 value 或者无参数调用 Object 函数，采用如下步骤： 如果 value 是 null、undefined 或未指定，则创建并返回一个新 Object 对象，这个对象与仿佛用相同参数调用标准内置的 Object 构造器 的结果一样。 返回 ToObject(value)。 Object 构造器当 Object 是 new 表达式调用的一部分时，它是一个构造器，可创建一个对象。 new Object ( [ value ] )当以一个参数 value 或者无参数调用 Object 构造器，采用如下步骤： 1. 如果提供了 value，则 1. 如果 Type(value) 是 Object，则 1. 如果 value 是个原生 ECMAScript 对象，不创建新对象，简单的返回 value。 2. 如果 value 是宿主对象，则采取动作和返回依赖实现的结果的方式可以使依赖于宿主对象的。 2. 如果 Type(value) 是 String，返回 ToObject(value)。 3. 如果 Type(value) 是 Boolean，返回 ToObject(value)。 4. 如果 Type(value) 是 Number，返回 ToObject(value)。 2. 断言：未提供参数 value 或其类型是 Null 或 Undefined。 3. 令 obj 为一个新创建的原生 ECMAScript 对象。 4. 设定 obj 的 [[Prototype]] 内部属性为标准内置的 Object 的 prototype 对象 (15.2.4)。 5. 设定 obj 的 [[Class]] 内部属性为 &quot;Object&quot;。 6. 设定 obj 的 [[Extensible]] 内部属性为 true。 7. 设定 obj 的 8.12 指定的所有内部方法 8. 返回 obj。 Object 构造器的属性Object 构造器的 [[Prototype]] 内部属性值是标准内置 Function 的 prototype 对象。 除了内部属性和 length 属性（其值是 1）之外，Object 构造器拥有以下属性： Object.prototypeObject.prototype 的初始值是标准内置 Object 的 prototype 对象这个属性包含特性 {[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } Object.getPrototypeOf ( O )当以参数 O 调用 getPrototypeOf 函数，采用如下步骤： 1. 如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。 2. 返回 O 的 [[Prototype]] 内部属性的值。 Object.getOwnPropertyDescriptor ( O, P )当调用 getOwnPropertyDescriptor 函数，采用如下步骤： 1. 如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。 2. 令 name 为 ToString(P)。 3. 令 desc 为以参数 name 调用 O 的 [[GetOwnProperty]] 内部方法的结果。 4. 返回调用 FromPropertyDescriptor(desc) 的结果。 Object.getOwnPropertyNames ( O )Object.create ( O [, Properties] )create 函数按照指定的原型创建一个新对象。当调用 create 函数，采用如下步骤： 1. 如果 Type(O) 不是 Object 或 Null，则抛出一个 TypeError 异常。 2. 令 obj 为仿佛是用表达式 new Object() 创建新对象的结果，这里的 Object 是标准内置构造器名。 3. 设定 obj 的 [[Prototype]] 内部属性为 O。 4. 如果传入了 Properties 参数并且不是 undefined，则仿佛是用 obj 和 Properties 当作参数调用标准内置函数 Object.defineProperties 一样给 obj 添加自身属性。 5. 返回 obj。 Object.defineProperty ( O, P, Attributes )defineProperty 函数用于给一个对象添加一个自身属性以及更新现有自身属性的特性。 Object.defineProperties ( O, Properties )defineProperties 函数用于给一个对象添加一些自身属性以及更新现有的一些自身属性的特性。 Object.seal ( O )当调用 seal 函数，采用如下步骤： 1. 如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。 2. 对 O 的每个命名自身属性名 P, 1. 令 desc 为以参数 P 调用 O 的 [[GetOwnProperty]] 内部方法的结果。 2. 如果 desc.[[Configurable]] 是 true，设定 desc.[[Configurable]] 为 false。 3. 以 P、desc、true 为参数调用 O 的 [[DefineOwnProperty]] 内部方法。 3. 设定 O 的 [[Extensible]] 内部属性为 false。 4. 返回 O。 Object.freeze ( O )当调用 freeze 函数，采用如下步骤： 1. 如果 Type(O) 不是 Object，则抛出一个 TypeError 异常。 2. 对 O 的每个命名自身属性名 P, 1. 令 desc 为以参数 P 调用 O 的 [[GetOwnProperty]] 内部方法的结果。 2. 如果 IsDataDescriptor(desc) 是 true，则 1. 如果 desc.[[Writable]] 是 true，设定 desc。[[Writable]] 为 false. 3. 如果 desc.[[Configurable]] 是 true，设定 desc。[[Configurable]] 为 false。 4. 以 P、desc、true 作为参数调用 O 的 [[DefineOwnProperty]] 内部方法。 3. 设定 O 的 [[Extensible]] 内部属性为 false。 4. 返回 O。 Object.preventExtensions ( O )当调用 preventExtensions 函数，采用如下步骤： 1. 如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . 2. 设定 O 的 [[Extensible]] 内部属性为 false。 3. 返回 O。 Object.isSealed ( O )Object.isFrozen ( O )Object.isExtensible ( O )Object.keys ( O )Object 的 prototype 对象的属性Object 的 prototype 对象的 [[Prototype]] 内部属性的值是 null ，[[Class]] 内部属性的值是 “Object”，[[Extensible]] 内部属性的初始值是 true。 Object.prototype.constructorObject.prototype.constructor 的初始值是标准内置的 Object 构造器。 Object.prototype.toString ( )当调用 toString 方法，采用如下步骤： 1. 如果 this 的值是 undefined，返回 &quot;[object Undefined]&quot;。 2. 如果 this 的值是 null，返回 &quot;[object Null]&quot;。 3. 令 O 为以 this 作为参数调用 ToObject 的结果。 4. 令 class 为 O 的 [[Class]] 内部属性的值。 5. 返回三个字符串 &quot;[object &quot;、class 和 &quot;]&quot; 连起来的字符串。 Object.prototype.toLocaleString ( )*toLocaleString 方法返回一个 String 对象，这个对象中包含了用当前区域设置的默认格式表示的日期。 Object.prototype.valueOf ( )Object.prototype.hasOwnProperty (V)Object.prototype.isPrototypeOf (V)*Object.prototype == V.constructor.prototype Object.prototype.propertyIsEnumerable (V)*属性V是否可枚举 Function ( . . . )Array ( . . . )数组原型对象的属性Array.prototype.constructorArray.prototype.constructor 的初始值是标准内置 Array 构造器。 Array.prototype.toString ( )Array.prototype.toLocaleString ( )先用数组元素的 toLocaleString 方法，将他们转换成字符串。然后将这些字符串串联，用一个分隔符分割，这里的分隔符字符串是与特定语言环境相关，由实现定义的方式得到的。调用这个函数的结果除了与特定语言环境关联之外，与 toString 的结果类似。 Array.prototype.concat ( [ item1 [ , item2 [ , … ] ] ] )当以零个或更多个参数 item1、item2，等，调用 concat 方法时，会返回一个数组。 返回的数组包含 调用对象的数组元素和随后顺序每个参数的数组元素。 Array.prototype.join (separator)数组元素先被转换为字符串，再将这些字符串用 separator 分割连接在一起。如果没提供分隔符，将一个逗号用作分隔符。 Array.prototype.pop ( )删除并返回数组的最后一个元素。 Array.prototype.push ( [ item1 [ , item2 [ , … ] ] ] )将参数以他们出现的顺序追加到数组末尾。数组的新 length 属性值会作为调用的结果返回。 Array.prototype.reverse ( )重新排列数组元素，以翻转它们的顺序。对象会被当做调用的结果返回。 Array.prototype.shift ( )删除并返回数组的第一个元素。 Array.prototype.slice (start, end)slice 方法需要 start 和 end 两个参数，返回一个数组，这个数组包含从下标为 start 的元素到下标为 end（不含 end）的元素（或如果 end 是 undefined 就到数组末尾）。如果 start 为负，它会被当做是 length + start，这里的 length 是数组长度。如果 end 为负，它会被当做是 length + end，这里的 length 是数组长度。 Array.prototype.sort (comparefn)给 this 数组的元素排序。排序不一定是稳定的（相等的元素们不一定按照他们原来的顺序排列）。如果 comparefn 不是 undefined，它就必须是个函数，这个函数接受两个参数 x 和 y，如果 x &lt; y 返回一个负值，如果 x = y 返回零，如果 x &gt; y 返回一个正值。 Array.prototype.splice (start, deleteCount [ , item1 [ , item2 [ , … ] ] ] )当以两个或更多参数 start、deleteCount 和（可选的）item1、item2, 等，调用 splice 方法，从数组索引 start 开始的 deleteCount 个数组元素会被替换为参数 item1、item2, 等。返回一个包含参数元素（如果有）的数组。 Array.prototype.unshift ( [ item1 [ , item2 [ , … ] ] ] )将参数们插入到数组的开始位置，它们在数组中的顺序与它们出现在参数列表中的顺序相同。 Array.prototype.indexOf ( searchElement [ , fromIndex ] )indexOf 按照索引的升序比较 searchElement 和数组里的元素们，它使用内部的严格相等比较算法（11.9.6），如果找到一个或更多这样的位置，返回这些位置中第一个索引；否则返回 -1。 Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )Array.prototype.every ( callbackfn [ , thisArg ] )Array.prototype.some ( callbackfn [ , thisArg ] )Array.prototype.forEach ( callbackfn [ , thisArg ] )callbackfn 应该是个函数，它接受三个参数。forEach 按照索引的升序，对数组里存在的每个元素调用一次 callbackfn。callbackfn 只被实际存在的数组元素调用；它不会被缺少的数组元素调用。 如果提供了一个 thisArg 参数，它会被当作 this 值传给每个 callbackfn 调用。如果没提供它，用 undefined 替代。 调用 callbackfn 时将传入三个参数：元素的值，元素的索引，和遍历的对象。 对 forEach 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。 forEach 处理的元素范围是在首次调用 callbackfn 之前设定的。在 forEach 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，forEach 访问这些元素时的值会传给 callbackfn；在 forEach 调用开始后删除的和之前被访问过的元素们是不访问的。 Array.prototype.map ( callbackfn [ , thisArg ] )callbackfn 应该是个函数，它接受三个参数。map 按照索引的升序，对数组里存在的每个元素调用一次 callbackfn，并用结果构造一个新数组。callbackfn 只被实际存在的数组元素调用；它不会被缺少的数组元素调用。 V8.png 如果提供了一个 thisArg 参数，它会被当作 this 值传给每个 callbackfn 调用。如果没提供它，用 undefined 替代。 调用 callbackfn 时将传入三个参数：元素的值，元素的索引，和遍历的对象。 对 map 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。 map 处理的元素范围是在首次调用 callbackfn 之前设定的。在 map 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，map 访问这些元素时的值会传给 callbackfn；在 map 调用开始后删除的和之前被访问过的元素们是不访问的。 Array.prototype.filter ( callbackfn [ , thisArg ] )callbackfn 应该是个函数，它接受三个参数并返回一个可转换为布尔值 true 和 false 的值。filter 按照索引的升序，对数组里存在的每个元素调用一次 callbackfn，并用使 callbackfn 返回 true 的所有值构造一个新数组。callbackfn 只被实际存在的数组元素调用；它不会被缺少的数组元素调用。 如果提供了一个 thisArg 参数，它会被当作 this 值传给每个 callbackfn 调用。如果没提供它，用 undefined 替代。 调用 callbackfn 时将传入三个参数：元素的值，元素的索引，和遍历的对象。 对 filter 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。 filter 处理的元素范围是在首次调用 callbackfn 之前设定的。在 filter 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，filter 访问这些元素时的值会传给 callbackfn；在 filter 调用开始后删除的和之前被访问过的元素们是不访问的。 Array.prototype.reduce ( callbackfn [ , initialValue ] )callbackfn 应该是个函数，它需要四个参数。reduce 按照索引的升序，对数组里存在的每个元素，将 callbackfn 作为回调函数调用一次。 调用 callbackfn 时将传入四个参数：previousValue（initialValue 的值或上次调用 callbackfn 的返回值）、currentValue（当前元素值）、currentIndex 和遍历的对象。第一次调用回调函数时，previousValue 和 currentValue 的取值可以是下面两种情况之一。如果为 reduce 调用提供了一个 initialValue，则 previousValue 将等于 initialValue 并且 currentValue 将等于数组的首个元素值。如果没提供 initialValue，则 previousValue 将等于数组的首个元素值并且 currentValue 将等于数组的第二个元素值。如果数组里没有元素并且没有提供 initialValue，则抛出一个 TypeError 异常。 对 reduce 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。 reduce 处理的元素范围是在首次调用 callbackfn 之前设定的。在 reduce 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，reduce 访问这些元素时的值会传给 callbackfn；在 reduce 调用开始后删除的和之前被访问过的元素们是不访问的。 Array.prototype.reduceRight ( callbackfn [ , initialValue ] )String ( . . . )String 构造器的属性String.prototypeString.prototype 的初始值是标准的内置 String 原型对象。 String.fromCharCode ( [ char0 [ , char1 [ , … ] ] ] )返回一个字符串值，包含的字符数与参数数目相同。每个参数指定返回字符串中的一个字符，也就是说第一个参数第一个字符，以此类推（从左到右）。一个参数转换为一个字符，通过先应用 ToUint16 操作，再将返回的16位整数看作字符的代码单元值。如果没提供参数，返回空字符串。 字符串原型对象的属性String.prototype.charCodeAt (pos)将 this 对象转换为一个字符串，返回一个代表这个字符串 pos 位置字符的代码单元值的数字（小于 216 的非负整数）。如果那个位置没有字符，返回 NaN。 String.prototype.localeCompare (that)当以一个参数 that 来调用 localeCompare 方法，它返回一个非 NaN 数字值，这个数字值反应了对 this 值（转换为字符串）和 that 值（转换为字符串）进行语言环境敏感的字符串比较的结果。两个字符串 S 和 That 用实现定义的一种方式进行比较。比较结果是按照系统默认语言环境指定的顺序来排列字符串。根据这三种情况：S 在 That 前面、两字符串相同、S 在 That 后面，分别返回：负数、零、正数。 String.prototype.search (regexp)String.prototype.trim ( )Boolean ( . . . )Number ( . . . )Number 构造器的属性Number.MAX_VALUENumber.MAX_VALUE 的值是 Number 类型的最大正有限值，约为 1.7976931348623157×10308。 Number.MIN_VALUENumber.MIN_VALUE 的值是 Number 类型的最小正有限值，约为 5×10-324。 Number.NEGATIVE_INFINITYNumber.POSITIVE_INFINITYNumber 原型对象的属性Number.prototype.toFixed (fractionDigits)返回一个包含了 代表 this Number 值的留有小数点后 fractionDigits 个数字的十进制固定小数点记法 的字符串。如果 fractionDigits 是 undefined，就认为是 0。 Number.prototype.toExponential (fractionDigits)返回一个代表 this Number 值 的科学计数法的字符串，它的有效数字的小数点前有一个数字，有效数字的小数点后有 fractionDigits 个数字。如果 fractionDigits 是 undefined，包括指定唯一 Number 值需要的尽可能多的有效数字（就像 ToString，但在这里总是以科学计数法输出）。 Number.prototype.toPrecision (precision)返回一个字符串，它代表 this Number 值 的科学计数法（有效数字的小数点前有一个数字，有效数字的小数点后有 precision - 1 个数字）或十进制固定计数法（precision 个有效数字）。如果 precision 是 undefined，用 ToString 调用代替。 Date ( . . . )RegExp ( . . . )Error ( . . . )EvalError ( . . . )RangeError ( . . . )ReferenceError ( . . . )SyntaxError ( . . . )TypeError ( . . . )URIError ( . . . )全局对象的其他属性MathJSON","tags":[{"name":"ES5","slug":"ES5","permalink":"https://willbean.github.io/tags/ES5/"},{"name":"Specification","slug":"Specification","permalink":"https://willbean.github.io/tags/Specification/"}]},{"title":"ES5规范回顾系列(一)——术语定义","date":"2017-07-02T06:01:58.000Z","path":"2017/07/02/es5-review-1/","text":"接触前端也有几个年头了，却发现自己从来没有好好的看看ECMAScript规范，闲来无事，就从ECMAScript2015看起吧~摘录部分内容到自己的博客，以备忘~ 英文原版在这 中文版在这 下文摘自ES5/概述 原始值在本规范的 第8章 定义的 Undefined、Null、Boolean、Number、String 类型之一的成员。*注： 原始值可以直接表示语言实现的最底层数据。 对象对象类型的成员。*注： 对象是属性的集合，并有一个原型对象。原型可以是空值。 构造器创建和初始化对象的函数对象。*注： 构造器的“prototype”属性值是一个原型对象，它用来实现继承和共享属性。 原型为其他对象提供共享属性的对象。*注： 当构造器创建一个对象时，为了解决对象的属性引用，该对象会隐式引用构造器的“prototype”属性。通过程序表达式 constructor.prototype 可以引用到构造器的“prototype”属性。并且，添加到对象原型里的属性会通过继承的方式与所有共享此原型的对象共享。另外，可使用 Object.create 内置函数，通过明确指定原型来创建一个新对象。 原生对象ECMAScript 实现中完全由本规范定义其语义而不掺入任何宿主环境定义的对象。*注： 标准的原生对象由本规范定义。一些原生对象是内置的，其他的可在 ECMAScript 程序执行过程中构建。 内置对象由 ECMAScript 实现提供，独立于宿主环境的对象，ECMAScript 程序开始执行时就存在。*注： 标准的内置对象由本规范定义，ECMAScript 实现可以指定和定义其他的。所有内置对象都是原生对象。内置构造器是个内置对象，同时也是个构造器。 宿主对象 由宿主环境提供的对象，用于完善 ECMAScript 执行环境。 *注： 任何不是原生对象的对象就是宿主对象。 String 值原始值，它是零个或多个16位无符号整数组成的有限有序序列。*注： String 值是 String 类型的成员。通常序列中的每个整数值代表 UTF-16 文本的单个16位单元。然而，对于其值，ECMAScript 只要求必须是16位无符号整数，除此之外没有任何限制或要求。 String 类型所有可能的 String 值的集合。 String 对象Object 类型的成员，它是标准内置构造器 String 的实例。*注： 通过使用 new 表达式，以一个 String 值为参数调用 String 构造器来创建 String 对象。由此产生的对象包含一个值为此 String 值的内部属性。将 String 构造器作为一个函数来调用，可将一个 String 对象强制转换为一个 String 值（15.5.1）。 Number 值原始值，对应一个64位双精度二进制 IEEE754 值。*注： Number 值是 Number 类型的成员，是一个数字的明确表示法 Number 类型所有可能的数字值的集合，包括特殊的“Not-a-Number”(NaN) 值、正无穷、负无穷。 Number 对象对象类型的成员，它是标准内置构造器 Number 的一个实例。*注： 通过使用 new 表达式，以一个数字值为参数调用 Number 构造器来创建数字对象。由此产生的对象包含一个值为此数字值的内部属性。将 Number 构造器作为一个函数来调用，可将一个 Number 对象强制转换为一个数字值（15.7.1）。 Infinity正无穷 Number 值。Note.png NaN值为 IEEE 754“Not-a-Number”的 Number 值。","tags":[{"name":"ES5","slug":"ES5","permalink":"https://willbean.github.io/tags/ES5/"},{"name":"Specification","slug":"Specification","permalink":"https://willbean.github.io/tags/Specification/"}]},{"title":"React Native实战总结","date":"2017-06-24T08:18:31.000Z","path":"2017/06/24/react-native-summary/","text":"入职有道数月，主要参与了精品课垂直页的改版，期间遇到了不少坑，虽然还未正式上线，但是也值得总结一波，故写下此文。 需求介绍 首页部分：加入日志控制工具以收集、统计用户操作；改写搜索框写法，将搜索框提取成独立的共用组件。 垂直页部分：此次改版集中在垂直页，新版垂直页将导航部分改版加入搜索框；重新设计了Banner部分；课程分类重新设计；课程入口信息增多样式改变；将原本的两列布局改成新版的一列布局，还加入了原本没有的（图片）小标题。 实现方案及问题一、日志控制首页布局 问题描述日志控制要求在Banner、课程分类列表、公开课列表、猜你喜欢、精选课程等模块出现在屏幕时发送一条日志，滑出屏幕再滑入也应该重新发送，其中Banner、课程分类列表和公开课列表是可以横向滑动的，滑动时要发送展示部分的日志，每个部分来回滚动也仅发送一次。 因为要获取各个部分的offsetTop和height，所以目前使用的方案是使用EventEmitter，在各组件onLayout的时候将组件的offsetTop和height发送给日志管理(LogControl)组件，为了方便使用，组件使用了单例模式,并继承了EventEmitter，在需要发送日志的组件下引入LogControl实例来传递信息，在Home组件的滚动事件下监听各组件的状态，如进入屏幕则发送日志。 相关代码123456789101112131415import Events from 'event-emitter'export default function LogControl() &#123; // 判断是否存在实例 if (typeof LogControl.instance === 'object') &#123; return LogControl.instance; &#125; this._listObject = &#123;&#125;; this._offsetTopList = &#123;&#125;; // 缓存 LogControl.instance = this;&#125;LogControl.prototype = new Events()LogControl.prototype.constructor = LogControl; 遇到问题及解决方案 安卓在组件滑动时会重复调用onLayout事件，导致日志重复发送。解决方案：在组件内增加一个属性判断是否触发过onLayout事件，是则不再调用。 安卓在初次进入首页加载完成后不会自动滚动，而IOS下会有滚动效果，导致安卓下只有在滑动了屏幕之后才会发送日志。解决方案一：安卓在加载完毕后手动调用scrollTo方法去触发一次onScroll事件。(未采用)解决方案二：在Home组件componentDidUpdate中调用一次LogControl中的方法去发送日志。 二、搜索框提取问题描述因为垂直页改版后需要使用到搜索框，故将原本只是用于首页的搜索框组件提取为公用组件，将相关样式改为了可配置的形式，由父组件通过参数传入，因为首页和垂直页的搜索页一致，所以保留了其样式，日后如有需要再进行修改。 相关代码12345678910111213141516&lt;Search isYoudaoCourseApp=&#123;this.state.isYoudaoCourseApp&#125; // setScrollViewEnableFunc=&#123;this.setScrollViewEnableFunc&#125; hasSearchBg=&#123;this.state.hasSearchBg&#125; setBarStyleFunc=&#123;this.setBarStyleFunc&#125; fadeAnim=&#123;this.state.fadeAnim&#125; searchContainerStyle=&#123;searchStyle.containerSearch&#125; searchOuterHideBarStyle=&#123;searchStyle.outerHideBar&#125; searchOuterStyle=&#123;searchStyle.outer&#125; searchOuterBgStyle=&#123;searchStyle.outerBg&#125; searchPlaceHolderStyle=&#123;searchStyle.searchPlaceHolder&#125; searchInputContainerStyle=&#123;searchStyle.searchInputCon&#125; searchInputStyle=&#123;[searchStyle.searchInput, &#123;backgroundColor: this.state.hasSearchBg ? 'rgba(233,233,233,.8)' : 'rgba(255,255,255,.8)'&#125;]&#125; searchIconStyle=&#123;searchStyle.icSearch&#125; /&gt; 三、导航栏布局旧版 新版 问题描述不同于旧版，新版导航去掉了原来的滚动条，改为了垂直标题+搜索框的形式。 遇到问题及解决方案 React native的元素堆叠顺序无法通过zIndex，所以如果将导航组件写在最前面的话，搜索页会被下面的ScrollView遮盖。解决方案：将搜索框改为绝对定位并置于文档最后。 导航标题字数不一，如果搜索框宽度固定，可能会与标题重叠。解决方案：在原有导航位置放置一个仅有背景色和高度的View组件，将标题和搜索框作为一个整体放置在文档最下面，然后通过绝对定位覆盖在View组件上层，此时搜索框就可以设置为自适应宽度了。 1234567&lt;View style=&#123;[styles.container, Platform.OS === 'android' &amp;&amp; !isTeacher ? &#123;marginTop: tag.get('hideStatusBar') ? statusBarHeight : 0&#125; : &#123;marginTop: 0&#125;]&#125;&gt; &#123;isTeacher ? null : &lt;View style=&#123;styles.headNav&#125;/&gt;&#125; // 这个&lt;View&gt;仅用于占位 &lt;ScrollView&gt; ... &lt;/ScrollView&gt; &#123;this._renderFixedNav(tag, this.state.isYoudaoCourseApp)&#125; // 真正的导航栏&lt;/View&gt; 四、Banner问题描述如上图，新版Banner每个图片并不占据整个屏宽，两边露出上下两张图片的一小部分，以做WEB的滑动组件的经验来说，要实现这样的功能，无非也就是通过绝对定位设置滚动栏，滚动时通过改变left或者translate来改变位置，如下图： 类推到这里，想要实现新版的效果，只需要将外层容器宽度设置成对应的数值，在设置overflow:visible即可，如下图： 在IOS端，一切正如我所料，相当之顺利，但是拿起安卓机一看，好像不太对劲，并没有出现预期的效果，Google一番得知，安卓不支持overflow属性！？ 由于原本使用的是第三方的react-native-swiper组件，出现这种情况赶紧翻看一下源码，看看能不能找到什么解决方案，然后发现在IOS端Swiper使用的是ScrollView，而在Android端使用的是ViewPagerAndroid，找了个安卓的朋友问了问，在原生安卓上使用ViewPager是可以实现这样的效果的(ViewPager实现一个页面多个Item的显示)，然而，ViewPagerAndroid并没有提供诸如clipChildren、layerType的属性，只能寻求别的方案了。 后来决定用Animate自己写一个滑动组件出来，写了个小demo，发现十分卡顿，可能姿势不对吧。 奋斗几天无果，后来在网上看到react-native-viewpager组件，无奈之下下载来看看源码，居然也是用Animate写的，感觉有戏！为了实现设计稿的效果，改了一下源码并拷贝出来作为一个自己的组件来使用。 用这个组件虽然实现了想要的效果，但是性能相较于ViewPagerAndroid确实要低一些，滑动过程中会有些许卡顿，为了不影响IOS端，IOS端还是保留了原来的写法，仅在Android端使用。 相关代码ViewPager组件源码修改123456var offset = this.props.offset; // 加入offset属性来设置偏移// this.childIndex = hasLeft ? 1 : 0;// this.state.scrollValue.setValue(this.childIndex);var translateX = this.state.scrollValue.interpolate(&#123; inputRange: [0, 1], outputRange: [offset, -viewWidth + offset] // 修改了滑动范围&#125;); ViewPager组件调用123456789&lt;ViewPager dataSource=&#123;ds&#125; renderPageIndicator=&#123;false&#125; isLoop=&#123;ds.pageIdentities.length &gt; 1&#125; autoPlay=&#123;true&#125; offset=&#123;calculatePixel(16)&#125; childWidth=&#123;calculatePixel(328)&#125; // 定义每个子元素的实际宽度（加入了边距） renderPage=&#123;this._renderBannerItem.bind(this)&#125;/&gt; 五、其他部分布局 问题描述如上图布局，更新还包括了课程分类的更新、加入了图片标题、课程入口的更新。 这一部分比较简单，似乎没啥好说的。 优化方案一、减少过度绘制在安卓机的开发者选项中可以开启“调试GPU过度绘制”，如下图： 关于安卓过度绘制的详情可以在这里查看，简单来说就是界面元素的多重层叠，假设每层元素都有背景，那么对于用户来说，只有最上层的背景才是可以看到的，其它的背景虽然绘制了，但是却没有起到效果，就是过度绘制了。 安卓GPU过度绘制的颜色信息大致如下： 蓝色1x过度绘制 绿色2x过度绘制 淡红色3x过度绘制 红色超过4x过度绘制 颜色越浅表示过度绘制程度越低，原色表示没有过度绘制。 现在来看看自己的APP会呈现出什么效果： 首页 垂直页 首页和垂直页差距似乎有点大，这里看到垂直页基本满屏大红，导致这个问题的原因不是垂直页充满了大量的背景，而是路由切换并没有把首页隐藏，垂直页相当于一整个元素覆盖在首页上方，所以看到的满屏大红是首页绘制加上垂直页绘制的效果，所以我们似乎找到了一个可以优化的地方：如何在路由切换的时候将首页隐藏或者像原生APP那样切换到一个新的界面？ 二、bundle拆包一般来说，一个简单的RN应用，打包之后的bundle会有500+KB是属于RN的依赖，与业务无关，而我们的APP将安卓打包之后生成的bundle有900+KB，其中绝大部分应该也是来自各种依赖文件，如果能将依赖和业务文件拆分开来，生成一个common.bundle、一个或多个business.bundle，那么我们可以在一定程度上改善用户体验。 减少初始时间（提前运行基础代码） 部分更新 在多个bundle之间共享公共模块 上图引自issue/5399，在用户进入应用之前，我们就可以加载并运行common.bundle，并在用户进入应用之后加载指定的业务文件，而不必一次性把所有东西都加载进行，以提升性能。 目前可参考的拆包方案有 携程是如何做React Native优化的 携程的moles-packer(携程似乎已经放弃这个方案，改为以unbundle为基础的拆包方案) 【React Native】一个简单的拆分Bundle&amp;资源做法 React Native Bundle Split react-native-split 问题总览 安卓RN不支持overflow属性 安卓ScrollView等组件在滑动的时候会触发自己和其他组件的onLayout事件 安卓line-height属性不支持小数 安卓在背景色过度设置的时候会严重影响性能","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://willbean.github.io/tags/Javascript/"},{"name":"HTML","slug":"HTML","permalink":"https://willbean.github.io/tags/HTML/"},{"name":"ReactNative","slug":"ReactNative","permalink":"https://willbean.github.io/tags/ReactNative/"}]},{"title":"Three.js实现仿IOS live图效果","date":"2017-05-09T12:57:44.000Z","path":"2017/05/09/live-photo-for-three/","text":"一、需求分析四月出游浪了一波，拍了一堆live图的照片，于是乎就想做个Web页，把这些照片展示出来，正逢最近学习了一些Three.js，就想着用上着技术做个小玩意出来。上网搜索了一波，苹果官网推出了一个live photos的框架，但是并不适用于canvas，就寻思着模仿着做一个吧~ 二、组件设计既然是模仿，那就要知道别人是怎么做的。新建了个HTML文件，导入livephotoskit.js，看着API写了个Demo，运行，开启开发者工具，粗略地研究了一下。因为将Live图导入到电脑中，会变为JPG和MOV格式的两个文件，大家都知道，一个是图片资源，一个是视频资源，而调用livephotoskit.js时也需要将着两个文件路径作为参数传入，渲染出来的是一个静态的图片，点击图片上方的按钮，就渐出隐藏图片，显示并播放置于图片后方的视频，当视频播放完毕后再渐入显示图片后隐藏视频。 那么就有大致的实现思路了：将图片和视频重叠放置，必要时显示或隐藏。 在看Three.js 实例的时候，发现了一个视频播放Demo，效果如下图（图片较大，可能加载很久甚至加载不出来）： 就想着将这个效果改一改，给用上。 为了便于复用，就将这个组件以类的形式编写出来吧。 这个类起码要包含以下属性和方法： options对象，传递组件长宽高、横向纵向块数、动画帧数 init方法，初始化操作，生成图片、视频实例 show方法，显示整个组件 hide方法，隐藏整个组件 play方法，播放视频 pause方法，暂停视频 三、效果展示 具体代码就不展示了，源码放在github，有兴趣的朋友可以去看看。","tags":[{"name":"Three.js","slug":"Three-js","permalink":"https://willbean.github.io/tags/Three-js/"},{"name":"Javascript","slug":"Javascript","permalink":"https://willbean.github.io/tags/Javascript/"},{"name":"HTML","slug":"HTML","permalink":"https://willbean.github.io/tags/HTML/"},{"name":"Canvas","slug":"Canvas","permalink":"https://willbean.github.io/tags/Canvas/"}]},{"title":"Ubuntu云服务器开启telnet实现远程登录","date":"2017-04-02T06:35:14.000Z","path":"2017/04/02/ubuntu-open-telnet/","text":"一、安装telnet服务1sudo apt-get install xinetd telnetd 二、修改/etc/xinetd.conf，在# log_type = SYSLOG daemon info下面添加内容12345instances = 60 log_type = SYSLOG authpriv log_on_success = HOST PID log_on_failure = HOST cps = 25 30 三、编辑/etc/xinetd.d/telnet文件（没有可自行创建此文件），添加以下内容12345678910111213# default: on # description: The telnet server serves telnet sessions; it uses \\ # unencrypted username/password pairs for authentication. service telnet &#123; disable = no flags = REUSE socket_type = stream wait = no user = root server = /usr/sbin/in.telnetd log_on_failure += USERID &#125; 四、重启机器或网络1sudo /etc/init.d/xinetd restart 五、通过telnet命令测试是否配置成功六、Windows下开启telnet服务七、使用CMD连接Linux服务器","tags":[{"name":"Configure","slug":"Configure","permalink":"https://willbean.github.io/tags/Configure/"},{"name":"Cloud Server","slug":"Cloud-Server","permalink":"https://willbean.github.io/tags/Cloud-Server/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://willbean.github.io/tags/Ubuntu/"},{"name":"Telnet","slug":"Telnet","permalink":"https://willbean.github.io/tags/Telnet/"}]},{"title":"Three.js obj模型转js并渲染","date":"2017-03-23T06:13:46.000Z","path":"2017/03/23/three.js-object-to-module/","text":"一、格式转化 下载python.到python官网https://www.python.org/进行下载，由于我是使用windows，所以直接下载了python3 windows的安装包，一路next完成安装，安装完成再配置一下环境变量即可。 下载three.js提供的格式转换文件——convert_obj_three.py （three.js官网可下载，或者到其github直接复制粘贴），注意版本，有python2和python3两个版本，按需下载。 将convert_obj_three.py 和你的obj文件放置同一目录，命令行下执行 1python convert_obj_three.py -i infile.obj -o outfile.js 该命令还有其他一些参数，详情可查阅convert_obj_three.py 注释部分。 二、模型渲染我使用的是three.js [r84]版本，较之前面版本有些不同。 12345678910111213let loader = new THREE.JSONLoader();loader.load('./img/port2.js', (geometry, materials)=&gt; &#123; var material = new THREE.MultiMaterial(materials); var object = new THREE.Mesh(geometry, material); scene.add(object); &#125;, function (xhr) &#123; console.log((xhr.loaded / xhr.total * 100) + '% loaded'); &#125;, // Function called when download errors function (xhr) &#123; console.error(xhr); &#125;);","tags":[{"name":"Three.js","slug":"Three-js","permalink":"https://willbean.github.io/tags/Three-js/"}]},{"title":"长轮询与服务器推送实现不同页面之间的通信","date":"2017-03-09T06:42:06.000Z","path":"2017/03/09/long-polling-and-server-push/","text":"前言：由于经常使用微信登录其他一些博客论坛什么的，就会经常遇到扫一扫登录的情况，大家都知道，我们平时访问的网页一般都是无连接的，也就是说需要数据的时候即便发出请求，服务器接受到请求之后便处理并返回相应的数据，这时连接就已经断开了，而使用扫一扫登陆的情况确是相反的，页面中的二维码一直等待着我们使用手机去扫描它，扫描过后页面完成登陆操作并进行一些跳转，那么问题来了，这是怎么实现的呢？怀着好奇心，先激活出二维码界面，再在浏览器上按下F12，切换到控制台，发现每隔几秒便有一个请求发出，稍微想想也就知道大致是怎么回事了，不就是长轮询嘛，实现的方法也挺多的，可以使用最原始的XMLHttpRequest，也可以使用WebSocket。最近也闲来没事做，就打算自己写个demo好了。 一、架构介绍既然是demo，我们也没必要搞太复杂，就用客户端A、服务器B、服务器C、客户端D表示吧。 客户端A模拟触发登录操作，服务器B接收到A的请求，B再告知服务器C要进行操作了，C接收到指令后通过服务器推送告诉客户端D显示确认或取消登录的按钮，当用户点击按钮后，D再向C发送一条请求，告知其用户的操作结果，再从C到B，B到A的顺序一步步返回。在C、D进行通信时，A、B发起的请求处于挂起（等待）状态，如果超时的话，就重新进行链接。 二、技术栈介绍服务器用到了node+koa，客户端仅仅使用了Html和js，客户端向服务器发送请求使用了XMLHttpRequest，服务器间通信使用request-promise模块，服务器向客户端推送数据使用EventSource，此demo没有使用WebSocket纯粹是因为从来没有用过EventSource想练练手，谁想踩了大坑，后文分解。 三、代码讲解又到了最愉快的贴代码时间~ 先展示一下目录结构： 1）request client &gt; index.html （客户端A代码） 1234567891011121314151617181920212223242526&lt;body&gt;&lt;button id=\"send\"&gt;发送请求&lt;/button&gt;&lt;script&gt; var send = document.querySelector('#send') send.onclick = function () &#123; polling('http://localhost:8888/longPolling',5000) &#125; function polling(url,timeout) &#123; var xhr = new XMLHttpRequest() xhr.open(\"get\",url) xhr.timeout = timeout; xhr.onreadystatechange = function () &#123; if( xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; alert('对方选择了·确定·') &#125;else if( xhr.readyState === 4 &amp;&amp; xhr.status === 204)&#123; alert('对方选择了·取消·') &#125; &#125; xhr.ontimeout = function () &#123; console.log('Timeout resend '+ new Date()); polling(url,5000) &#125; xhr.send() &#125;&lt;/script&gt;&lt;/body&gt; 一个按钮，绑定了polling函数，传入请求地址与超时时间，超时则重新请求。 2.1）request server &gt; app.js （服务器B代码） 123456789101112131415'use strict';const Koa = require('koa');const app = new Koa();const router = require('koa-router')();const cors = require('koa-cors');const routers = require('./routes');let repPort = 8888;router.use('/', routers.routes(), routers.allowedMethods());app.use(cors());app.use(router.routes(), router.allowedMethods());app.listen(repPort) 2.2）request server &gt; routes &gt; index.js （服务器B路由） 123456789101112131415161718192021const router = require('koa-router')()const rp = require('request-promise');let resHostname = 'localhost';let resPort = 8889;router.get('longPolling', function* (next)&#123; let options = &#123; uri : `http://$&#123;resHostname&#125;:$&#123;resPort&#125;/btServer`, method : 'post' &#125;; yield rp(options).then(data=&gt;&#123; this.status = parseInt(data); console.log('Finished') &#125;).catch(err=&gt;&#123; console.log(`error message:$&#123;err&#125;`) &#125;);&#125;);module.exports = router; 接收A发来的请求，使用request-promise向C发送请求，同时挂起处理以等待响应。 3.1）responce server &gt; app.js （服务器C代码） 123456789101112131415161718const Koa = require('koa');const app = new Koa();const render = require('koa-render');const router = require('koa-router')();const routes = require('./routes');const convert = require('koa-convert');const bodyparser = require('koa-bodyparser')();let port = 8889;router.use('/', routes.routes());app.use(convert(bodyparser));app.use(require('koa-static')(__dirname + '/public'));app.use(render());app.use(router.routes());app.listen(port); 3.2）responce server &gt; routes &gt; index.js （服务器C路由） 123456789101112131415161718192021222324252627282930313233343536const router = require('koa-router')()const EL = require('../EventListener');const el = new EL();router.post('btServer', function *(next) &#123;// 客户端服务器请求 let resBody = 0; el.sendEnsureMsg(); yield new Promise((resolve, reject)=&gt; &#123; el.once('receive', ()=&gt; &#123; if (el.status === 'yes') &#123; resBody = 200; &#125; else if (el.status === 'no') &#123; resBody = 204; &#125; resolve(); &#125;); &#125;); this.body = resBody; this.status = 200;&#125;).get('ensure',function* (next) &#123; //向客户端推送信息 let self = this; this.set(\"content-type\",\"text/event-stream\"); yield new Promise((resolve, reject)=&gt; &#123; el.once('ensure', ()=&gt; &#123; console.log('Has send'); resolve(); &#125;); &#125;); self.body = 'data: ensure\\n\\n'; this.status = 200;&#125;).post('sure', function*(next) &#123; //客户端相应推送 el.receiveEnsureMsg(this.request.body.data) this.status = 200;&#125;);module.exports = router; 3.3 的代码继承了events模块，封装了两个方法，一个用来触发服务器推送，一个用来响应客户端D返回的数据。 3.2 中订阅事件使用了该事件监听类并使用了once方法，以防止超时重传时重复订阅此事件。 在调试过程中D一直无法接收到C推送的数据，迟迟查不出原因，最后多方百度才发现，原来EventSource的数据必须以“data: something \\n\\n”的格式传输，我真是了了。 4）responce server &gt; public &gt;index.html (客户端D代码） 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt;&lt;div id=\"container\" style=\"display: none\"&gt; &lt;button id=\"yes\"&gt;确定&lt;/button&gt; &lt;button id=\"no\"&gt;取消&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var yes = document.querySelector(\"#yes\") var no = document.querySelector(\"#no\") var container = document.querySelector(\"#container\") var eventSource = new EventSource('/ensure') eventSource.onmessage = function (e) &#123; if(e.data === 'ensure')&#123; container.style.display = 'block' eventSource.close() &#125; &#125; eventSource.onerror = function (err) &#123; console.log(`EventSource error:`); console.log(err); &#125; yes.onclick = function () &#123; postMsg('data=yes') &#125; no.onclick = function () &#123; postMsg('data=no') &#125; function postMsg(msg) &#123; var xhr = new XMLHttpRequest() xhr.open('post','/sure') xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; container.style.display = 'none' &#125; &#125; xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.send(msg) &#125;&lt;/script&gt;&lt;/body&gt; 客户端D的代码没有独立开来而放在了response server文件夹下是因为EventSource要求与请求的服务器同源，就直接给它放在了静态资源下。 总结：好了，代码贴完了，其实并没有什么含金量，就是坑特多。 就这样吧，代码放github了。 传送门：https://github.com/WillBean/long-polling.git","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://willbean.github.io/tags/Javascript/"},{"name":"HTML","slug":"HTML","permalink":"https://willbean.github.io/tags/HTML/"},{"name":"长轮询","slug":"长轮询","permalink":"https://willbean.github.io/tags/长轮询/"},{"name":"服务器推送","slug":"服务器推送","permalink":"https://willbean.github.io/tags/服务器推送/"}]},{"title":"Node爬虫爬取网页静态资源","date":"2016-12-11T06:30:50.000Z","path":"2016/12/11/node-crawler/","text":"一、准备工作 首先当然是安装node，这一步忽略。 然后是各种模块，本实例用到了http、fs、url、cheerio、request、async、phantom，前三个是node自带的，无需install。 因为要服务器渲染，所以要用到phantomjs，这个需要自行安装一下，最后再配置一下全局环境。 二、模块解释 cheerio模块用于解析DOM树，进行DOM操作， 具体用法跟JQuery类似，对熟悉JQ的人来说，学会使用也就是几分钟的事。 request模块，http模块的高级封装版，便于操作。 async模块，解决“恶魔金字塔”问题。 phantom模块，在服务器端渲染整个界面，为的是能够爬取到页面上一些通过js等动态加载的内容。 三、具体实现1. 公用接口1234exports.Strategy = &#123;//js,css,images等文件的保存策略 \"SAVE_IN_ROOT\": 1,//保存在根目录下 \"SAVE_IN_SUB_DIR\": 2//保存在各级子目录下&#125;; 12345678910111213exports.uniqueArray = function (arr) &#123;//数组去重 var hash = &#123;&#125;, len = arr.length, result = []; for (var i = 0; i &lt; len; i++)&#123; if (!hash[arr[i]])&#123; hash[arr[i]] = true; result.push(arr[i]); &#125; &#125; return result;&#125;; 123exports.timer = function (date,msg) &#123;//简易版计时器 console.log(msg + \" : \"+(new Date() - date) +\"ms\" );&#125;; 2. 配置1234567891011var config = &#123; url: \"http://localhost:8081/dhay/\",//目的网站 savePath: \"J:/nodejs/open-source-spider\",//保存路径 containOutLink: false, //是否爬取外部链接 totalNum: 10, //爬取页面上限，0为不限制 endWith: \"html\",//文件结尾 saveStrategy: publicAPI.Strategy.SAVE_IN_ROOT, getOuterJs: false,//是否爬取远端js getOuterCss: false,//是否爬取远端Css getOuterImages: false//是否爬取远端图片&#125;; 为了简化操作，判断是否为外部资源的方式简化为判断URL是否以http或https为开头，虽然不够严谨，但是能保证爬取下来的网页能根据URL获取到资源。 保存策略目前也只实现了SAVE_IN_ROOT而已，懒~ 3. 全局变量 1234 var list = [config.url]; //所要爬取的网页链接队列var count = 0; //当前爬取的网页数var date = null; var urlInfo = url.parse(config.url); //入口链接信息 4. 获取服务器渲染之后的页面12345678910phantom.create().then(function (ph) &#123; ph.createPage().then(function (page) &#123; page.open(url).then(function (status) &#123; if (status == 'success') &#123; page.property('content').then(function (html) &#123; console.log(html); &#125; &#125; &#125;) &#125;); 5. 解析DOM树12345678910111213141516171819var $ = cheerio.load(html);var js, css , images;//获取js列表var scripts = $(\"script\");js = getJs(scripts);console.log(js);//获取cssvar stylesheets = $(\"link[rel='stylesheet']\");css = getCss(stylesheets);console.log(css);//获取图片var imgs = $(\"img\");images = getImages(imgs);console.log(images);//获取链接if(!config.totalNum || count &lt; config.totalNum)&#123; var links = $(\"a\"); getLink(links,url);&#125; 获取页面中所有的js、css和img，分别进行调用函数，返回所要爬取的文件的url数组。 6. getJs()等函数1234567891011121314function getJs(scripts) &#123; var res = []; scripts.each(function (i, script) &#123; var src = script.attribs.src; if (!src) return; if (!config.getOuterJs) &#123; if (/^https?/.test(src)) return; &#125; res.push(src); &#125;); return publicAPI.uniqueArray(res);&#125; getJs()函数，遍历每一个元素，判断其src属性是否存在，不存在则跳过，再根据配置判断是否获取外部文件，满足各条件的加入到res数组中，最后去重后返回结果。 getCss、getImages和getLink方法与上述类似，不同的是getLink多了一些判断和URL格式化操作。 7. 保存网页文本 12345678910111213141516171819202122232425262728293031323334353637383940 var saveHtml = function (url, html, callback) &#123; url = url.match(/https?:\\/\\/((?:(?![\\?])[\\S])*)/)[1];//截取？以前的字符串 var endWith = /\\/$/.test(url); //判断是否以反斜杠结尾 url = endWith ? url.match(/(\\S*)\\/$/)[1] : url; //去除反斜杠 var reg = new RegExp(/\\.html|\\.htm|\\.asp|\\.jsp$/); //判断是否以这些字符串结尾 var usePathAsName = reg.test(url); var array = url.split(\"/\"); //以反斜杠分割字符串 array[0] = urlInfo.hostname; var length = usePathAsName ? array.length-1: array.length; var currentPath = config.savePath; for (var i = 0; i &lt; length; i++) &#123; //遍历数组，逐层判断当前路径是否存在指定文件夹，不存在则创建 (function (i) &#123; currentPath += \"/\" + array[i]; if (fs.existsSync(currentPath)) &#123; write(i, callback) &#125; else &#123; try &#123; fs.mkdirSync(currentPath); write(i, callback) &#125;catch (err)&#123; console.log(err); &#125; &#125; &#125;)(i) &#125; function write(index, callback) &#123; // 若为最后一个元素，执行写入操作 if (index == length - 1) &#123; var fileName = endWith ? \"index.\" + config.endWith : usePathAsName ? array[array.length-1] : array[array.length-1] + config.endWith; //根据情况选择文件名 fs.writeFile(currentPath + \"/\" + fileName, html, function (err) &#123; if (err) &#123; console.log(err, \"appendFile\"); &#125; else &#123; callback(); &#125; &#125;); &#125; &#125;&#125;; 8. 保存js等资源1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var saveJs = function (url, js, callback ,callback2) &#123; if(!js.length)&#123; callback2(null); return; &#125; var length = js.length; var count = 0; var root = config.savePath + \"/\" + urlInfo.hostname; if(config.saveStrategy == publicAPI.Strategy.SAVE_IN_ROOT)&#123; if(fs.existsSync(root))&#123; write(callback,callback2) &#125;else&#123; fs.mkdirSync(root); write(callback,callback2) &#125; &#125; function write(callback,callback2) &#123; for(var i = 0;i&lt;length;i++)&#123; (function (i) &#123; var reg = new RegExp(/^\\//); var path = reg.test(js[i]) ? js[i].substring(1) : js[i]; var array = path.split(\"/\"); var currentPath = root; var len = array.length; for(var j =0;j&lt;len-1;j++)&#123; //创建对应目录 (function (j) &#123; currentPath += \"/\" + array[j]; if (fs.existsSync(currentPath)) &#123; if(j == len-2)&#123; fetch(js[i],function () &#123; callback(count, js[i]) &#125;,callback2) &#125; &#125; else &#123; try &#123; fs.mkdirSync(currentPath);console.log(j,4); if(j == len-2)&#123; fetch(js[i],function () &#123; callback(count, js[i]) &#125;,callback2) &#125; &#125;catch (err)&#123; console.log(\"error!\") &#125; &#125; &#125;)(j); &#125; &#125;)(i); &#125; &#125; function fetch(js,callback,callback2) &#123; request(url+js,function (err,res,body) &#123; //获取资源，再写入 //console.log(body); js = js.match(/((?:(?![\\?])[\\S])*)/)[1]; if(err)&#123; count++; &#125;else&#123; fs.writeFile(root +\"/\"+ js,body,function (err) &#123; count++; if(count == length) callback2(null); if(err)&#123; console.log(err); &#125;else&#123; callback(); &#125; &#125;); &#125; &#125;) &#125;&#125;; 保存js等资源的方法比保存网页的更为复杂，主要是因为一个页面可能存在多个js、css等资源，这里有两种保存的策略，一是直接将所有文件保存在根目录下，如根目录如localhost，现有js文件链接为“localhost:8080//abc/js/main/js”，将该js文件保存在localhost/js/下，另一种是保存在对应目录下，即localhost/abc/js/下，但是第二种方法会导致出现很多重复的文件，就没有实现出来。 获取css、images的方法类似，不做赘述。 9. 并行执行写入操作 1234567891011121314151617181920212223242526272829303132333435 async.parallel([ function (callback) &#123; saveHtml(url, html, function () &#123; console.log(\"Page:\"+(count+1)+\" Url:\"+url+\" success!\\n\"); callback(null); &#125;); &#125;, function (callback) &#123; saveJs(url,js, function (x, js) &#123; console.log(\"Page:\"+(count+1)+\" Js\"+(x+1)+\" Src:\"+js+\" Success!\\n\"); &#125;,callback); &#125;, function (callback) &#123; saveCss(url, css, function (x, css) &#123; console.log(\"Page:\"+(count+1)+\" Css\"+(x+1)+\" Src:\"+css+\" Success!\\n\"); &#125;,callback); &#125;, function (callback) &#123; saveImage(url, images, function (x,img) &#123; console.log(\"Page:\"+(count+1)+\" Images\"+(x+1)+\" Src:\"+img+\" Success!\\n\"); &#125;,callback); &#125;],function (err) &#123; page.close(); if(err)&#123; console.log(err,\"ERROR IN PARALLEL PAGE \"+(count+1)); &#125;else &#123; count++; console.log(\"Page:\"+(count)+\" finished!\"); var cur = list.shift(),next = list[0]; next = /^https?:/.test(next) ? next : cur+'/'+next; if( count &lt; config.totalNum) requirePage(next); &#125;&#125;) 用async模块，并行处理写入操作，当所有写入操作结束后，从list队列获取下一跳地址，循环操作。 10. 测试 爬取http://localhost:8081/ 结果如图：","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://willbean.github.io/tags/Javascript/"},{"name":"Crawler","slug":"Crawler","permalink":"https://willbean.github.io/tags/Crawler/"},{"name":"Node","slug":"Node","permalink":"https://willbean.github.io/tags/Node/"}]},{"title":"腾讯云ubuntu服务器配置","date":"2016-11-07T10:59:23.000Z","path":"2016/11/07/cloud-server-configure/","text":"零、域名绑定从腾讯云服务的云解析里解析域名并绑定服务器公网即可。 一、安装mysql123sudo apt-get install mysql-serversudo apt-get isntall mysql-clientsudo apt-get install libmysqlclient-dev 第一部会提示输入密码。经过以上三部，如无意外，mysql就配置好了。 二、安装node偷个懒先进入root模式，大家不要学我，这样不好不好。(补：一下方法是使用ubuntu自带的node包进行安装，node版本可能比较低，可跳过，使用源码安装) 12345apt-get updateapt-get install -y python-software-properties software-properties-common add-apt-repository ppa:chris-lea/node.jsapt-get updateapt-get install nodejs 安装过程有那么一些些慢。zzzZZZ…… 然而，安装完发现node版本低到离谱，只能从官网下载新版本源码，手动安装。如果下载过于缓慢，可以先上传到git，再从git上下载。(如https://nodejs.org/dist/v6.10.0/node-v6.10.0.tar.gz) 123456789apt-get remove nodejs # 先将原本的一波带走wget https://xxxxxxxx # 下载node源码tar zxvf [source] # 解压apt-get install g++ make # 安装编译工具cd [source]./configuremake # 完成之后找到&lt;node&gt;应用程序的地址make installln -s [源地址] /usr/bin/node # 软链接到/usr/bin/以作用于全局 然后准备安装npm，先安装curl： 123apt-get install curlcurl -L https://npmjs.org/install.sh | sh ln -s [源地址] /usr/bin/npm 然而问题又出现了，npm的下载速度慢得实在蛋疼，故又还得下载cnpm。 12npm install -g cnpm --registry=https://registry.npm.taobao.orgln -s [源地址] /usr/bin/cnpm 三、安装git12apt-get updateapt-get install git 四、安装nginx1apt-get install nginx 一条命令足以，安装nginx主要用于静态资源的管理和反向代理，其实只有node服务器也是可以的。 安装完成后执行： /etc/init.d/nginx start 即可启动服务器。 默认的web文件路径为 /usr/share/nginx/html，个人不大习惯，想改一改。 用 ngnix -t 可找到ngnix.conf配置文件的路径，然后用vim编辑。 如果没有server段，则在http{}内自己添加 12345678910111213141516171819202122232425262728293031server &#123; listen 80; server_name www.xx.com; #设定本虚拟主机的访问日志 #access_log logs/www.xx.com.access.log main; location / &#123; root /var/www/; index index.php index.html index.htm; &#125; location ~ \\.php$ &#123; fastcgi_pass 127.0.0.1:9000 ###或者使用socket，要与www.conf中同步 fastcgi_index index.php fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 或者直接更改nginx的默认文件/etc/nginx/sites-available/default，修改对应的server、location，/etc/init.d/nginx restart 重启服务器即可 五、配置php环境官网下载php源码包，安装过程基本同node，略…… php源码编译之前要安装libxml2 1apt-get install libxml2* -y 对于php7，what is very important!!! 编译时使用 ./configure –enable-fpm php7自带fpm，无需另外下载。下载好之后开始配置。找到php-fpm.conf.default文件，一般位于/usr/local/etc/下 12cp php-fpm.conf.default php-fpm.confvim php-fpm.conf 将error_log注释打开，将include引向正确地址如：include /usr/local/etc/php-fpm.d/*.conf 找到www.conf.default文件，一般位于/usr/local/etc/php-fpm.d/下 12cp www.conf.default www.confvim www.conf 将user和group中的nobody改为www-data,执行/usr/local/sbin/php-fpm启动fpm 结语原本配置过一次腾讯云的服务器了，当时弄了好几天才弄好，结果实在是懒，几个月没搭理，就被腾讯给回收了，香菇。。。为了方便以后配置，故整合了一下网络资源，写下了此博客，无奈。。。","tags":[{"name":"Configure","slug":"Configure","permalink":"https://willbean.github.io/tags/Configure/"},{"name":"Cloud Server","slug":"Cloud-Server","permalink":"https://willbean.github.io/tags/Cloud-Server/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://willbean.github.io/tags/Ubuntu/"}]}]