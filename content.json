[{"title":"react-native-summary","date":"2017-06-24T08:18:31.000Z","path":"2017/06/24/react-native-summary/","text":"React Native实战总结入职有道数月，主要参与了精品课垂直页的改版，期间遇到了不少坑，虽然还未正式上线，但是也值得总结一波，故写下此文。 需求介绍 首页部分：加入日志控制工具以收集、统计用户操作；改写搜索框写法，将搜索框提取成独立的共用组件。 垂直页部分：此次改版集中在垂直页，新版垂直页将导航部分改版加入搜索框；重新设计了Banner部分；课程分类重新设计；课程入口信息增多样式改变；将原本的两列布局改成新版的一列布局，还加入了原本没有的（图片）小标题。 实现方案及问题一、日志控制首页布局 问题描述日志控制要求在Banner、课程分类列表、公开课列表、猜你喜欢、精选课程等模块出现在屏幕时发送一条日志，滑出屏幕再滑入也应该重新发送，其中Banner、课程分类列表和公开课列表是可以横向滑动的，滑动时要发送展示部分的日志，每个部分来回滚动也仅发送一次。 因为要获取各个部分的offsetTop和height，所以目前使用的方案是使用EventEmitter，在各组件onLayout的时候将组件的offsetTop和height发送给日志管理(LogControl)组件，为了方便使用，组件使用了单例模式,并继承了EventEmitter，在需要发送日志的组件下引入LogControl实例来传递信息，在Home组件的滚动事件下监听各组件的状态，如进入屏幕则发送日志。 相关代码123456789101112131415import Events from 'event-emitter'export default function LogControl() &#123; // 判断是否存在实例 if (typeof LogControl.instance === 'object') &#123; return LogControl.instance; &#125; this._listObject = &#123;&#125;; this._offsetTopList = &#123;&#125;; // 缓存 LogControl.instance = this;&#125;LogControl.prototype = new Events()LogControl.prototype.constructor = LogControl; 遇到问题及解决方案 安卓在组件滑动时会重复调用onLayout事件，导致日志重复发送。解决方案：在组件内增加一个属性判断是否触发过onLayout事件，是则不再调用。 安卓在初次进入首页加载完成后不会自动滚动，而IOS下会有滚动效果，导致安卓下只有在滑动了屏幕之后才会发送日志。解决方案一：安卓在加载完毕后手动调用scrollTo方法去触发一次onScroll事件。(未采用)解决方案二：在Home组件componentDidUpdate中调用一次LogControl中的方法去发送日志。 二、搜索框提取问题描述因为垂直页改版后需要使用到搜索框，故将原本只是用于首页的搜索框组件提取为公用组件，将相关样式改为了可配置的形式，由父组件通过参数传入，因为首页和垂直页的搜索页一致，所以保留了其样式，日后如有需要再进行修改。 相关代码12345678910111213141516&lt;Search isYoudaoCourseApp=&#123;this.state.isYoudaoCourseApp&#125; // setScrollViewEnableFunc=&#123;this.setScrollViewEnableFunc&#125; hasSearchBg=&#123;this.state.hasSearchBg&#125; setBarStyleFunc=&#123;this.setBarStyleFunc&#125; fadeAnim=&#123;this.state.fadeAnim&#125; searchContainerStyle=&#123;searchStyle.containerSearch&#125; searchOuterHideBarStyle=&#123;searchStyle.outerHideBar&#125; searchOuterStyle=&#123;searchStyle.outer&#125; searchOuterBgStyle=&#123;searchStyle.outerBg&#125; searchPlaceHolderStyle=&#123;searchStyle.searchPlaceHolder&#125; searchInputContainerStyle=&#123;searchStyle.searchInputCon&#125; searchInputStyle=&#123;[searchStyle.searchInput, &#123;backgroundColor: this.state.hasSearchBg ? 'rgba(233,233,233,.8)' : 'rgba(255,255,255,.8)'&#125;]&#125; searchIconStyle=&#123;searchStyle.icSearch&#125; /&gt; 三、导航栏布局旧版 新版 问题描述不同于旧版，新版导航去掉了原来的滚动条，改为了垂直标题+搜索框的形式。 遇到问题及解决方案 React native的元素堆叠顺序无法通过zIndex，所以如果将导航组件写在最前面的话，搜索页会被下面的ScrollView遮盖。解决方案：将搜索框改为绝对定位并置于文档最后。 导航标题字数不一，如果搜索框宽度固定，可能会与标题重叠。解决方案：在原有导航位置放置一个仅有背景色和高度的View组件，将标题和搜索框作为一个整体放置在文档最下面，然后通过绝对定位覆盖在View组件上层，此时搜索框就可以设置为自适应宽度了。 1234567&lt;View style=&#123;[styles.container, Platform.OS === 'android' &amp;&amp; !isTeacher ? &#123;marginTop: tag.get('hideStatusBar') ? statusBarHeight : 0&#125; : &#123;marginTop: 0&#125;]&#125;&gt; &#123;isTeacher ? null : &lt;View style=&#123;styles.headNav&#125;/&gt;&#125; // 这个&lt;View&gt;仅用于占位 &lt;ScrollView&gt; ... &lt;/ScrollView&gt; &#123;this._renderFixedNav(tag, this.state.isYoudaoCourseApp)&#125; // 真正的导航栏&lt;/View&gt; 四、Banner问题描述如上图，新版Banner每个图片并不占据整个屏宽，两边露出上下两张图片的一小部分，以做WEB的滑动组件的经验来说，要实现这样的功能，无非也就是通过绝对定位设置滚动栏，滚动时通过改变left或者translate来改变位置，如下图： 类推到这里，想要实现新版的效果，只需要将外层容器宽度设置成对应的数值，在设置overflow:visible即可，如下图： 在IOS端，一切正如我所料，相当之顺利，但是拿起安卓机一看，好像不太对劲，并没有出现预期的效果，Google一番得知，安卓不支持overflow属性！？ 由于原本使用的是第三方的react-native-swiper组件，出现这种情况赶紧翻看一下源码，看看能不能找到什么解决方案，然后发现在IOS端Swiper使用的是ScrollView，而在Android端使用的是ViewPagerAndroid，找了个安卓的朋友问了问，在原生安卓上使用ViewPager是可以实现这样的效果的(ViewPager实现一个页面多个Item的显示)，然而，ViewPagerAndroid并没有提供诸如clipChildren、layerType的属性，只能寻求别的方案了。 后来决定用Animate自己写一个滑动组件出来，写了个小demo，发现十分卡顿，可能姿势不对吧。 奋斗几天无果，后来在网上看到react-native-viewpager组件，无奈之下下载来看看源码，居然也是用Animate写的，感觉有戏！为了实现设计稿的效果，改了一下源码并拷贝出来作为一个自己的组件来使用。 用这个组件虽然实现了想要的效果，但是性能相较于ViewPagerAndroid确实要低一些，滑动过程中会有些许卡顿，为了不影响IOS端，IOS端还是保留了原来的写法，仅在Android端使用。 相关代码ViewPager组件源码修改123456var offset = this.props.offset; // 加入offset属性来设置偏移// this.childIndex = hasLeft ? 1 : 0;// this.state.scrollValue.setValue(this.childIndex);var translateX = this.state.scrollValue.interpolate(&#123; inputRange: [0, 1], outputRange: [offset, -viewWidth + offset] // 修改了滑动范围&#125;); ViewPager组件调用123456789&lt;ViewPager dataSource=&#123;ds&#125; renderPageIndicator=&#123;false&#125; isLoop=&#123;ds.pageIdentities.length &gt; 1&#125; autoPlay=&#123;true&#125; offset=&#123;calculatePixel(16)&#125; childWidth=&#123;calculatePixel(328)&#125; // 定义每个子元素的实际宽度（加入了边距） renderPage=&#123;this._renderBannerItem.bind(this)&#125;/&gt; 五、其他部分布局 问题描述如上图布局，更新还包括了课程分类的更新、加入了图片标题、课程入口的更新。 这一部分比较简单，似乎没啥好说的。 优化方案一、减少过度绘制在安卓机的开发者选项中可以开启“调试GPU过度绘制”，如下图： 关于安卓过度绘制的详情可以在这里查看，简单来说就是界面元素的多重层叠，假设每层元素都有背景，那么对于用户来说，只有最上层的背景才是可以看到的，其它的背景虽然绘制了，但是却没有起到效果，就是过度绘制了。 安卓GPU过度绘制的颜色信息大致如下： 蓝色1x过度绘制 绿色2x过度绘制 淡红色3x过度绘制 红色超过4x过度绘制 颜色越浅表示过度绘制程度越低，原色表示没有过度绘制。 现在来看看自己的APP会呈现出什么效果： 首页 垂直页 首页和垂直页差距似乎有点大，这里看到垂直页基本满屏大红，导致这个问题的原因不是垂直页充满了大量的背景，而是路由切换并没有把首页隐藏，垂直页相当于一整个元素覆盖在首页上方，所以看到的满屏大红是首页绘制加上垂直页绘制的效果，所以我们似乎找到了一个可以优化的地方：如何在路由切换的时候将首页隐藏或者像原生APP那样切换到一个新的界面？ 二、bundle拆包一般来说，一个简单的RN应用，打包之后的bundle会有500+KB是属于RN的依赖，与业务无关，而我们的APP将安卓打包之后生成的bundle有900+KB，其中绝大部分应该也是来自各种依赖文件，如果能将依赖和业务文件拆分开来，生成一个common.bundle、一个或多个business.bundle，那么我们可以在一定程度上改善用户体验。 减少初始时间（提前运行基础代码） 部分更新 在多个bundle之间共享公共模块 上图引自issue/5399，在用户进入应用之前，我们就可以加载并运行common.bundle，并在用户进入应用之后加载指定的业务文件，而不必一次性把所有东西都加载进行，以提升性能。 目前可参考的拆包方案有 携程是如何做React Native优化的 携程的moles-packer(携程似乎已经放弃这个方案，改为以unbundle为基础的拆包方案) 【React Native】一个简单的拆分Bundle&amp;资源做法 React Native Bundle Split react-native-split 问题总览 安卓RN不支持overflow属性 安卓ScrollView等组件在滑动的时候会触发自己和其他组件的onLayout事件 安卓line-height属性不支持小数 安卓在背景色过度设置的时候会严重影响性能","tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://willbean.github.io/tags/ReactNative/"}]},{"title":"node-crawler","date":"2016-12-11T06:30:50.000Z","path":"2016/12/11/node-crawler/","text":"Node爬虫爬取网页静态资源一、准备工作 首先当然是安装node，这一步忽略。 然后是各种模块，本实例用到了http、fs、url、cheerio、request、async、phantom，前三个是node自带的，无需install。 因为要服务器渲染，所以要用到phantomjs，这个需要自行安装一下，最后再配置一下全局环境。 二、模块解释 cheerio模块用于解析DOM树，进行DOM操作， 具体用法跟JQuery类似，对熟悉JQ的人来说，学会使用也就是几分钟的事。 request模块，http模块的高级封装版，便于操作。 async模块，解决“恶魔金字塔”问题。 phantom模块，在服务器端渲染整个界面，为的是能够爬取到页面上一些通过js等动态加载的内容。 三、具体实现1. 公用接口1234exports.Strategy = &#123;//js,css,images等文件的保存策略 \"SAVE_IN_ROOT\": 1,//保存在根目录下 \"SAVE_IN_SUB_DIR\": 2//保存在各级子目录下&#125;; 12345678910111213exports.uniqueArray = function (arr) &#123;//数组去重 var hash = &#123;&#125;, len = arr.length, result = []; for (var i = 0; i &lt; len; i++)&#123; if (!hash[arr[i]])&#123; hash[arr[i]] = true; result.push(arr[i]); &#125; &#125; return result;&#125;; 123exports.timer = function (date,msg) &#123;//简易版计时器 console.log(msg + \" : \"+(new Date() - date) +\"ms\" );&#125;; 2. 配置1234567891011var config = &#123; url: \"http://localhost:8081/dhay/\",//目的网站 savePath: \"J:/nodejs/open-source-spider\",//保存路径 containOutLink: false, //是否爬取外部链接 totalNum: 10, //爬取页面上限，0为不限制 endWith: \"html\",//文件结尾 saveStrategy: publicAPI.Strategy.SAVE_IN_ROOT, getOuterJs: false,//是否爬取远端js getOuterCss: false,//是否爬取远端Css getOuterImages: false//是否爬取远端图片&#125;; 为了简化操作，判断是否为外部资源的方式简化为判断URL是否以http或https为开头，虽然不够严谨，但是能保证爬取下来的网页能根据URL获取到资源。 保存策略目前也只实现了SAVE_IN_ROOT而已，懒~ 3. 全局变量 1234 var list = [config.url]; //所要爬取的网页链接队列var count = 0; //当前爬取的网页数var date = null; var urlInfo = url.parse(config.url); //入口链接信息 4. 获取服务器渲染之后的页面12345678910phantom.create().then(function (ph) &#123; ph.createPage().then(function (page) &#123; page.open(url).then(function (status) &#123; if (status == 'success') &#123; page.property('content').then(function (html) &#123; console.log(html); &#125; &#125; &#125;) &#125;); 5. 解析DOM树12345678910111213141516171819var $ = cheerio.load(html);var js, css , images;//获取js列表var scripts = $(\"script\");js = getJs(scripts);console.log(js);//获取cssvar stylesheets = $(\"link[rel='stylesheet']\");css = getCss(stylesheets);console.log(css);//获取图片var imgs = $(\"img\");images = getImages(imgs);console.log(images);//获取链接if(!config.totalNum || count &lt; config.totalNum)&#123; var links = $(\"a\"); getLink(links,url);&#125; 获取页面中所有的js、css和img，分别进行调用函数，返回所要爬取的文件的url数组。 6. getJs()等函数1234567891011121314function getJs(scripts) &#123; var res = []; scripts.each(function (i, script) &#123; var src = script.attribs.src; if (!src) return; if (!config.getOuterJs) &#123; if (/^https?/.test(src)) return; &#125; res.push(src); &#125;); return publicAPI.uniqueArray(res);&#125; getJs()函数，遍历每一个元素，判断其src属性是否存在，不存在则跳过，再根据配置判断是否获取外部文件，满足各条件的加入到res数组中，最后去重后返回结果。 getCss、getImages和getLink方法与上述类似，不同的是getLink多了一些判断和URL格式化操作。 7. 保存网页文本 12345678910111213141516171819202122232425262728293031323334353637383940 var saveHtml = function (url, html, callback) &#123; url = url.match(/https?:\\/\\/((?:(?![\\?])[\\S])*)/)[1];//截取？以前的字符串 var endWith = /\\/$/.test(url); //判断是否以反斜杠结尾 url = endWith ? url.match(/(\\S*)\\/$/)[1] : url; //去除反斜杠 var reg = new RegExp(/\\.html|\\.htm|\\.asp|\\.jsp$/); //判断是否以这些字符串结尾 var usePathAsName = reg.test(url); var array = url.split(\"/\"); //以反斜杠分割字符串 array[0] = urlInfo.hostname; var length = usePathAsName ? array.length-1: array.length; var currentPath = config.savePath; for (var i = 0; i &lt; length; i++) &#123; //遍历数组，逐层判断当前路径是否存在指定文件夹，不存在则创建 (function (i) &#123; currentPath += \"/\" + array[i]; if (fs.existsSync(currentPath)) &#123; write(i, callback) &#125; else &#123; try &#123; fs.mkdirSync(currentPath); write(i, callback) &#125;catch (err)&#123; console.log(err); &#125; &#125; &#125;)(i) &#125; function write(index, callback) &#123; // 若为最后一个元素，执行写入操作 if (index == length - 1) &#123; var fileName = endWith ? \"index.\" + config.endWith : usePathAsName ? array[array.length-1] : array[array.length-1] + config.endWith; //根据情况选择文件名 fs.writeFile(currentPath + \"/\" + fileName, html, function (err) &#123; if (err) &#123; console.log(err, \"appendFile\"); &#125; else &#123; callback(); &#125; &#125;); &#125; &#125;&#125;; 8. 保存js等资源1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var saveJs = function (url, js, callback ,callback2) &#123; if(!js.length)&#123; callback2(null); return; &#125; var length = js.length; var count = 0; var root = config.savePath + \"/\" + urlInfo.hostname; if(config.saveStrategy == publicAPI.Strategy.SAVE_IN_ROOT)&#123; if(fs.existsSync(root))&#123; write(callback,callback2) &#125;else&#123; fs.mkdirSync(root); write(callback,callback2) &#125; &#125; function write(callback,callback2) &#123; for(var i = 0;i&lt;length;i++)&#123; (function (i) &#123; var reg = new RegExp(/^\\//); var path = reg.test(js[i]) ? js[i].substring(1) : js[i]; var array = path.split(\"/\"); var currentPath = root; var len = array.length; for(var j =0;j&lt;len-1;j++)&#123; //创建对应目录 (function (j) &#123; currentPath += \"/\" + array[j]; if (fs.existsSync(currentPath)) &#123; if(j == len-2)&#123; fetch(js[i],function () &#123; callback(count, js[i]) &#125;,callback2) &#125; &#125; else &#123; try &#123; fs.mkdirSync(currentPath);console.log(j,4); if(j == len-2)&#123; fetch(js[i],function () &#123; callback(count, js[i]) &#125;,callback2) &#125; &#125;catch (err)&#123; console.log(\"error!\") &#125; &#125; &#125;)(j); &#125; &#125;)(i); &#125; &#125; function fetch(js,callback,callback2) &#123; request(url+js,function (err,res,body) &#123; //获取资源，再写入 //console.log(body); js = js.match(/((?:(?![\\?])[\\S])*)/)[1]; if(err)&#123; count++; &#125;else&#123; fs.writeFile(root +\"/\"+ js,body,function (err) &#123; count++; if(count == length) callback2(null); if(err)&#123; console.log(err); &#125;else&#123; callback(); &#125; &#125;); &#125; &#125;) &#125;&#125;; 保存js等资源的方法比保存网页的更为复杂，主要是因为一个页面可能存在多个js、css等资源，这里有两种保存的策略，一是直接将所有文件保存在根目录下，如根目录如localhost，现有js文件链接为“localhost:8080//abc/js/main/js”，将该js文件保存在localhost/js/下，另一种是保存在对应目录下，即localhost/abc/js/下，但是第二种方法会导致出现很多重复的文件，就没有实现出来。 获取css、images的方法类似，不做赘述。 9. 并行执行写入操作 1234567891011121314151617181920212223242526272829303132333435 async.parallel([ function (callback) &#123; saveHtml(url, html, function () &#123; console.log(\"Page:\"+(count+1)+\" Url:\"+url+\" success!\\n\"); callback(null); &#125;); &#125;, function (callback) &#123; saveJs(url,js, function (x, js) &#123; console.log(\"Page:\"+(count+1)+\" Js\"+(x+1)+\" Src:\"+js+\" Success!\\n\"); &#125;,callback); &#125;, function (callback) &#123; saveCss(url, css, function (x, css) &#123; console.log(\"Page:\"+(count+1)+\" Css\"+(x+1)+\" Src:\"+css+\" Success!\\n\"); &#125;,callback); &#125;, function (callback) &#123; saveImage(url, images, function (x,img) &#123; console.log(\"Page:\"+(count+1)+\" Images\"+(x+1)+\" Src:\"+img+\" Success!\\n\"); &#125;,callback); &#125;],function (err) &#123; page.close(); if(err)&#123; console.log(err,\"ERROR IN PARALLEL PAGE \"+(count+1)); &#125;else &#123; count++; console.log(\"Page:\"+(count)+\" finished!\"); var cur = list.shift(),next = list[0]; next = /^https?:/.test(next) ? next : cur+'/'+next; if( count &lt; config.totalNum) requirePage(next); &#125;&#125;) 用async模块，并行处理写入操作，当所有写入操作结束后，从list队列获取下一跳地址，循环操作。 10. 测试 爬取http://localhost:8081/ 结果如图：","tags":[{"name":"Node, Crawler","slug":"Node-Crawler","permalink":"https://willbean.github.io/tags/Node-Crawler/"}]},{"title":"cloud-server-configure","date":"2016-11-07T10:59:23.000Z","path":"2016/11/07/cloud-server-configure/","text":"腾讯云ubuntu服务器配置零、域名绑定从腾讯云服务的云解析里解析域名并绑定服务器公网即可。 一、安装mysql123sudo apt-get install mysql-serversudo apt-get isntall mysql-clientsudo apt-get install libmysqlclient-dev 第一部会提示输入密码。经过以上三部，如无意外，mysql就配置好了。 二、安装node偷个懒先进入root模式，大家不要学我，这样不好不好。(补：一下方法是使用ubuntu自带的node包进行安装，node版本可能比较低，可跳过，使用源码安装) 12345apt-get updateapt-get install -y python-software-properties software-properties-common add-apt-repository ppa:chris-lea/node.jsapt-get updateapt-get install nodejs 安装过程有那么一些些慢。zzzZZZ…… 然而，安装完发现node版本低到离谱，只能从官网下载新版本源码，手动安装。如果下载过于缓慢，可以先上传到git，再从git上下载。(如https://nodejs.org/dist/v6.10.0/node-v6.10.0.tar.gz) 123456789apt-get remove nodejs # 先将原本的一波带走wget https://xxxxxxxx # 下载node源码tar zxvf [source] # 解压apt-get install g++ make # 安装编译工具cd [source]./configuremake # 完成之后找到&lt;node&gt;应用程序的地址make installln -s [源地址] /usr/bin/node # 软链接到/usr/bin/以作用于全局 然后准备安装npm，先安装curl： 123apt-get install curlcurl -L https://npmjs.org/install.sh | sh ln -s [源地址] /usr/bin/npm 然而问题又出现了，npm的下载速度慢得实在蛋疼，故又还得下载cnpm。 12npm install -g cnpm --registry=https://registry.npm.taobao.orgln -s [源地址] /usr/bin/cnpm 三、安装git12apt-get updateapt-get install git 四、安装nginx1apt-get install nginx 一条命令足以，安装nginx主要用于静态资源的管理和反向代理，其实只有node服务器也是可以的。 安装完成后执行： /etc/init.d/nginx start 即可启动服务器。 默认的web文件路径为 /usr/share/nginx/html，个人不大习惯，想改一改。 用 ngnix -t 可找到ngnix.conf配置文件的路径，然后用vim编辑。 如果没有server段，则在http{}内自己添加 12345678910111213141516171819202122232425262728293031server &#123; listen 80; server_name www.xx.com; #设定本虚拟主机的访问日志 #access_log logs/www.xx.com.access.log main; location / &#123; root /var/www/; index index.php index.html index.htm; &#125; location ~ \\.php$ &#123; fastcgi_pass 127.0.0.1:9000 ###或者使用socket，要与www.conf中同步 fastcgi_index index.php fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 或者直接更改nginx的默认文件/etc/nginx/sites-available/default，修改对应的server、location，/etc/init.d/nginx restart 重启服务器即可 五、配置php环境官网下载php源码包，安装过程基本同node，略…… php源码编译之前要安装libxml2 1apt-get install libxml2* -y 对于php7，what is very important!!! 编译时使用 ./configure –enable-fpm php7自带fpm，无需另外下载。下载好之后开始配置。找到php-fpm.conf.default文件，一般位于/usr/local/etc/下 12cp php-fpm.conf.default php-fpm.confvim php-fpm.conf 将error_log注释打开，将include引向正确地址如：include /usr/local/etc/php-fpm.d/*.conf 找到www.conf.default文件，一般位于/usr/local/etc/php-fpm.d/下 12cp www.conf.default www.confvim www.conf 将user和group中的nobody改为www-data,执行/usr/local/sbin/php-fpm启动fpm 结语原本配置过一次腾讯云的服务器了，当时弄了好几天才弄好，结果实在是懒，几个月没搭理，就被腾讯给回收了，香菇。。。为了方便以后配置，故整合了一下网络资源，写下了此博客，无奈。。。","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://willbean.github.io/tags/ubuntu/"}]}]